{
  "name": "Calendar Agent v4 (Quick Appointments)",
  "nodes": [
    {
      "parameters": {},
      "id": "trigger-1",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [-1184, 288]
    },
    {
      "parameters": {
        "jsCode": "// === PARSEAR SOLICITUD v4 - CON VALIDACI√ìN +24H Y EXTRACCI√ìN DE DATOS ===\nconst inputJson = $input.item.json || {};\nconst query = (inputJson.query || '').toLowerCase();\nconst queryOriginal = inputJson.query || '';\nconst customerEmail = inputJson.customerEmail || '';\nconst pendingBookingIn = inputJson.pendingBooking || null;\nlet customerData = inputJson.customerData || null;\n\n// Acciones\nconst isBooking = /(agendar|reservar|programar|book|cita)/i.test(query);\nconst isCancel = /(cancelar|eliminar|quitar)/i.test(query);\nconst isCheck = /(disponible|horario|cuando|available)/i.test(query);\nconst isConfirm = /(confirmar|confirmo|si confirmo|confirm|yes)/i.test(query);\n\nlet action = 'check';\nif (isBooking) action = 'book';\nif (isCancel) action = 'cancel';\nif (isConfirm) action = 'confirm';\n\n// NUEVO: Detectar formato CUSTOMER_DATA:{...} en el query\nconst customerDataMatch = queryOriginal.match(/CUSTOMER_DATA:(\\{[^}]+\\})/i);\nif (customerDataMatch && pendingBookingIn) {\n  try {\n    const parsed = JSON.parse(customerDataMatch[1]);\n    if (parsed.name && parsed.email) {\n      customerData = parsed;\n      action = 'create_event';\n    }\n  } catch (e) {\n    console.log('Error parsing CUSTOMER_DATA:', e);\n  }\n}\n\n// Extraer datos del cliente si viene en formato JSON desde customerData param\nif (!customerData && pendingBookingIn && typeof inputJson.customerData === 'string' && inputJson.customerData.trim().startsWith('{')) {\n  try {\n    const parsed = JSON.parse(inputJson.customerData);\n    if (parsed.name && parsed.email) {\n      customerData = parsed;\n      action = 'create_event';\n    }\n  } catch (e) {\n    // Si no es JSON v√°lido, intentar extraer manualmente\n  }\n}\n\n// Extracci√≥n manual si pendingBooking existe pero no hay customerData\nif (pendingBookingIn && !customerData && !isCancel && !isConfirm) {\n  const emailMatch = queryOriginal.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/i);\n  const nameMatch = queryOriginal.match(/(?:nombre|name|me llamo|soy)\\s*:?\\s*([A-Za-z√Å√â√ç√ì√ö√°√©√≠√≥√∫√ë√±\\s]+)(?=\\n|email|\\.|,|$)/i);\n  \n  if (emailMatch && nameMatch) {\n    customerData = {\n      name: nameMatch[1].trim(),\n      email: emailMatch[0].trim(),\n      reason: queryOriginal.substring(0, 100)\n    };\n    action = 'create_event';\n  }\n}\n\n// Detectar si el usuario est√° respondiendo a la petici√≥n de datos para agendar\nif (pendingBookingIn && customerData && typeof customerData === 'object' && !isCancel && !isConfirm) {\n  action = 'create_event';\n}\n\n// Extraer d√≠a y hora\nlet targetDate = null;\nlet targetTime = null;\nif (action === 'book') {\n  const daysEs = ['lunes','martes','miercoles','jueves','viernes','sabado','domingo'];\n  const daysEn = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];\n  for (let i = 0; i < 7; i++) {\n    const d = new Date();\n    const diff = (i + 7 - d.getDay() + 1) % 7 || 7;\n    d.setDate(d.getDate() + diff);\n    if (query.includes(daysEs[i]) || query.includes(daysEn[i])) {\n      targetDate = d.toISOString().split('T')[0];\n      break;\n    }\n  }\n  const timeMatch = query.match(/(\\d{1,2})(?::(\\d{2}))?\\s?(am|pm)?/i);\n  if (timeMatch) {\n    let [_, h, m, p] = timeMatch;\n    let hours = parseInt(h);\n    const minutes = m || '00';\n    if (p) {\n      if (p.toLowerCase() === 'pm' && hours !== 12) hours += 12;\n      if (p.toLowerCase() === 'am' && hours === 12) hours = 0;\n    }\n    targetTime = `${hours.toString().padStart(2,'0')}:${minutes}`;\n  }\n\n  // NUEVO: Validar +24h anticipaci√≥n\n  if (targetDate && targetTime) {\n    const proposedDateTime = new Date(`${targetDate}T${targetTime}:00-06:00`);\n    const minDateTime = new Date(Date.now() + 24*60*60*1000); // +24h\n\n    if (proposedDateTime < minDateTime) {\n      return [{\n        json: {\n          output: '‚è∞ Solo aceptamos citas con al menos **24 horas de anticipaci√≥n** para poder confirmarlas adecuadamente.\\n\\nEsto nos permite asegurar que recibir√°s tu email de confirmaci√≥n y podr√°s confirmar tu asistencia a tiempo.\\n\\n¬øQuieres ver horarios disponibles para m√°s adelante?',\n          action: 'error',\n          needsData: false,\n          pendingBooking: null,\n          validationFailed: true\n        }\n      }];\n    }\n  }\n}\n\nreturn [{\n  json: {\n    query,\n    action,\n    targetDate,\n    targetTime,\n    customerEmail,\n    customerData,\n    pendingBookingIn\n  }\n}];"
      },
      "id": "parse-request",
      "name": "Parse Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-960, 288]
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "mode": "list",
          "value": "primary"
        },
        "limit": 100,
        "options": {
          "orderBy": "startTime",
          "timeMin": "={{ new Date().toISOString() }}",
          "timeMax": "={{ new Date(Date.now() + 7*24*60*60*1000).toISOString() }}"
        }
      },
      "id": "get-events",
      "name": "Get Events",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [-736, 288],
      "alwaysOutputData": true,
      "continueOnFail": true,
      "onError": "continueRegularOutput",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "YOUR_GOOGLE_CALENDAR_CREDENTIAL_ID",
          "name": "Google Calendar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === PROCESAR ACCI√ìN v4 - HORARIOS DIN√ÅMICOS ===\n// Obtener datos del Parse Request (primer item del nodo anterior)\nconst parseData = $('Parse Request').item.json;\nconst { action, targetDate, targetTime, customerEmail, customerData, pendingBookingIn, validationFailed } = parseData;\n\n// Si ya fall√≥ validaci√≥n, pasar directo\nif (validationFailed) {\n  return [{ json: parseData }];\n}\n\n// Manejar error de Google Calendar (continueOnFail)\nconst allItems = $input.all();\nconst hasError = allItems.length === 0 || allItems.some(i => i.json.error || Object.keys(i.json).length === 0);\nconst events = hasError ? [] : allItems.filter(i => i.json.id).map(i => i.json);\nconst allowedTimes = ['09:00','10:00','11:00','14:00','15:00','16:00','17:00'];\n\nlet response = '';\nlet needsData = false;\nlet pendingBooking = null;\nlet cancelEventId = null;\nlet pendingUpdate = null;\nlet shouldCreateEvent = false;\nlet shouldDeleteEvent = false;\nlet shouldUpdateEvent = false;\n\nif (action === 'check') {\n  response = `üìÖ **Disponibilidad esta semana (CDMX, GMT-6)**\\n\\n`;\n  const days = ['Domingo','Lunes','Martes','Mi√©rcoles','Jueves','Viernes','S√°bado'];\n  for (let i = 1; i < 8; i++) {\n    const d = new Date();\n    d.setDate(d.getDate() + i);\n    if (d.getDay() === 0 || d.getDay() === 6) continue;\n    const dateStr = d.toISOString().split('T')[0];\n    \n    // NUEVO: Horarios din√°micos con buffer de 15 min\n    const busySlots = events\n      .filter(e => e.start?.dateTime?.startsWith(dateStr))\n      .map(e => ({\n        start: new Date(new Date(e.start.dateTime).getTime() - 15*60*1000),\n        end: new Date(new Date(e.end.dateTime).getTime() + 15*60*1000)\n      }));\n\n    const availableTimes = allowedTimes.filter(time => {\n      const proposedStart = new Date(`${dateStr}T${time}:00-06:00`);\n      const proposedEnd = new Date(proposedStart.getTime() + 30*60*1000); // 30 min\n\n      return !busySlots.some(busy =>\n        proposedStart < busy.end && proposedEnd > busy.start\n      );\n    });\n\n    if (availableTimes.length > 0) {\n      response += `**${days[d.getDay()]} ${d.getDate()}**: ${availableTimes.join(', ')}\\n`;\n    }\n  }\n  response += `\\nüí° **Duraci√≥n:** 30 minutos\\n‚ö†Ô∏è **Importante:** Debes confirmar tu cita en 24h v√≠a email o ser√° cancelada autom√°ticamente.\\n\\n¬øQu√© d√≠a y hora prefieres? (Ej: \"Jueves a las 3 PM\")`;\n\n} else if (action === 'book') {\n  if (!targetDate || !targetTime || !allowedTimes.includes(targetTime)) {\n    response = `‚è∞ Necesito un horario v√°lido. Ejemplo: \"Martes a las 10 AM\"\\n\\n**Horarios disponibles:** Lunes a Viernes, 9-11 AM y 2-5 PM`;\n  } else {\n    const startISO = `${targetDate}T${targetTime}:00-06:00`;\n    const endISO = new Date(new Date(startISO).getTime() + 30*60*1000).toISOString();\n    \n    // NUEVO: Verificar conflictos con buffer de 15 min\n    const busySlots = events\n      .filter(e => e.start?.dateTime?.startsWith(targetDate))\n      .map(e => ({\n        start: new Date(new Date(e.start.dateTime).getTime() - 15*60*1000),\n        end: new Date(new Date(e.end.dateTime).getTime() + 15*60*1000)\n      }));\n\n    const proposedStart = new Date(startISO);\n    const proposedEnd = new Date(endISO);\n\n    const conflict = busySlots.some(busy =>\n      proposedStart < busy.end && proposedEnd > busy.start\n    );\n\n    if (conflict) {\n      response = `‚ùå Lo siento, ese horario ya est√° ocupado o muy cerca de otra cita.\\n\\n¬øQuieres ver otros horarios disponibles?`;\n    } else {\n      response = `‚úÖ ¬°Perfecto! Confirmemos tu cita r√°pida:\\n\\nüìÖ **${new Date(startISO).toLocaleString('es-MX',{weekday:'long',month:'long',day:'numeric',hour:'numeric',minute:'numeric'})}**\\n‚è±Ô∏è Duraci√≥n: 30 minutos\\nüé• Incluye enlace de videollamada\\n\\nPara confirmar, necesito:\\n1. **Nombre completo**\\n2. **Email**\\n3. **¬øDe qu√© trata tu consulta?** (breve)\\n\\n‚ö†Ô∏è **Importante:** Recibir√°s un email de confirmaci√≥n. Debes confirmar en las pr√≥ximas 24 horas o tu cita ser√° cancelada autom√°ticamente.\\n\\n_Responde con esta info y agendar√© tu cita._`;\n      needsData = true;\n      pendingBooking = { start: startISO, end: endISO };\n    }\n  }\n\n} else if (action === 'create_event') {\n  response = `Creando tu cita...`;\n  shouldCreateEvent = true;\n\n} else if (action === 'cancel') {\n  if (!customerEmail) {\n    response = `Para cancelar, necesito el email con el que agendaste.`;\n  } else {\n    const pending = events.find(e => \n      e.attendees?.some(a => a.email === customerEmail) && \n      (e.summary.includes('[PENDIENTE') || e.summary.includes('[CONFIRMADA'))\n    );\n    if (pending) {\n      cancelEventId = pending.id;\n      shouldDeleteEvent = true;\n      response = `Cancelando tu cita...`;\n    } else {\n      response = `No encontr√© ninguna cita con tu email **${customerEmail}**.`;\n    }\n  }\n\n} else if (action === 'confirm') {\n  response = `Para confirmar tu cita, usa el bot√≥n en el email que te enviamos. Si no lo recibiste, cont√°ctanos a hey@aurin.mx`;\n}\n\nreturn [{\n  json: {\n    output: response,\n    needsData,\n    pendingBooking,\n    cancelEventId,\n    pendingUpdate,\n    action,\n    customerData: parseData.customerData,\n    pendingBookingIn: parseData.pendingBookingIn,\n    shouldCreateEvent,\n    shouldDeleteEvent,\n    shouldUpdateEvent\n  }\n}];"
      },
      "id": "process-action",
      "name": "Process Action",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-512, 288]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            { "value1": "={{ $json.shouldCreateEvent }}", "value2": true }
          ]
        }
      },
      "id": "if-create",
      "name": "IF Create Event",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [-288, 32]
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "mode": "list",
          "value": "primary"
        },
        "start": "={{ $json.pendingBookingIn.start }}",
        "end": "={{ $json.pendingBookingIn.end }}",
        "title": "={{ '[PENDIENTE CONFIRMACI√ìN] Cita R√°pida - ' + $json.customerData.name }}",
        "description": "={{ 'Consulta: ' + ($json.customerData.reason || 'No especificado') + '\\n\\nEsta cita requiere confirmaci√≥n del usuario en las pr√≥ximas 24 horas.\\n\\nContacto: ' + $json.customerData.email }}",
        "useDefaultReminders": false,
        "additionalFields": {
          "attendees": "={{ $json.customerData.email }}",
          "conferenceDataVersion": 1
        }
      },
      "id": "create-event",
      "name": "Create Event",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [-64, -80],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "YOUR_GOOGLE_CALENDAR_CREDENTIAL_ID",
          "name": "Google Calendar"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://aurin.mx/api/send-appointment-confirmation",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\\n  \\\"name\\\": $json.customerData.name,\\n  \\\"email\\\": $json.customerData.email,\\n  \\\"appointmentDate\\\": $('Create Event').item.json.start.dateTime,\\n  \\\"meetLink\\\": $('Create Event').item.json.hangoutLink,\\n  \\\"eventId\\\": $('Create Event').item.json.id,\\n  \\\"calendarLink\\\": $('Create Event').item.json.htmlLink\\n} }}",
        "options": {}
      },
      "id": "send-confirmation",
      "name": "Send Confirmation Email",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [160, -80]
    },
    {
      "parameters": {
        "jsCode": "const event = $('Create Event').item.json;\nconst customerData = $('Process Action').item.json.customerData;\n\nif (!event || !event.hangoutLink) {\n  return [{ json: { output: '‚ùå Error al crear evento. Por favor, int√©ntalo de nuevo.' } }];\n}\n\nreturn [{\n  json: {\n    output: `‚úÖ **¬°Cita reservada exitosamente, ${customerData.name}!**\\n\\nüìÖ **${new Date(event.start.dateTime).toLocaleString('es-MX',{weekday:'long',month:'long',day:'numeric',hour:'numeric',minute:'numeric'})}**\\n‚è±Ô∏è Duraci√≥n: 30 minutos\\nüé• Enlace Meet: ${event.hangoutLink}\\n\\nüìß **IMPORTANTE:** Te enviamos un email de confirmaci√≥n a **${customerData.email}**.\\n\\n‚ö†Ô∏è **Debes confirmar tu cita en las pr√≥ximas 24 horas haciendo clic en el bot√≥n del email, o ser√° cancelada autom√°ticamente.**\\n\\nSi no recibes el email en los pr√≥ximos minutos, revisa tu carpeta de spam o cont√°ctanos en hey@aurin.mx\\n\\n¬øHay algo m√°s en lo que te pueda ayudar?`,\n    eventId: event.id,\n    meetLink: event.hangoutLink,\n    calendarLink: event.htmlLink,\n    requiresConfirmation: true,\n    customerEmail: customerData.email,\n    pendingBooking: null\n  }\n}];"
      },
      "id": "final-response",
      "name": "Final Booking Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [384, -80]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            { "value1": "={{ $json.shouldDeleteEvent }}", "value2": true }
          ]
        }
      },
      "id": "if-delete",
      "name": "IF Delete Event",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [-288, 400]
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "mode": "list",
          "value": "primary"
        },
        "eventId": "={{ $json.cancelEventId }}",
        "options": {
          "sendUpdates": "all"
        }
      },
      "id": "delete-event",
      "name": "Delete Event",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [-64, 288],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "YOUR_GOOGLE_CALENDAR_CREDENTIAL_ID",
          "name": "Google Calendar"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { \\n  output: `‚úÖ Cita cancelada exitosamente.\\n\\n¬øDeseas agendar una nueva cita r√°pida?`,\\n  customerEmail: null,\\n  pendingBooking: null\\n} }];"
      },
      "id": "cancel-response",
      "name": "Cancel Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [160, 288]
    },
    {
      "parameters": {
        "jsCode": "// Pasar respuesta directa si no se ejecutan operaciones de Google Calendar\nreturn [$json];"
      },
      "id": "passthrough",
      "name": "Passthrough Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-64, 160]
    },
    {
      "parameters": {
        "jsCode": "// Extraer solo el output para devolver al LangChain toolWorkflow\nconst output = $json.output || 'Error: No se pudo procesar la solicitud';\nreturn [{ json: { output } }];"
      },
      "id": "format-output",
      "name": "Format Output for LangChain",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [160, 160]
    }
  ],
  "pinData": {},
  "connections": {
    "Execute Workflow Trigger": {
      "main": [[{ "node": "Parse Request", "type": "main", "index": 0 }]]
    },
    "Parse Request": {
      "main": [[{ "node": "Get Events", "type": "main", "index": 0 }]]
    },
    "Get Events": {
      "main": [[{ "node": "Process Action", "type": "main", "index": 0 }]]
    },
    "Process Action": {
      "main": [[
        { "node": "IF Create Event", "type": "main", "index": 0 },
        { "node": "IF Delete Event", "type": "main", "index": 0 },
        { "node": "Passthrough Response", "type": "main", "index": 0 }
      ]]
    },
    "IF Create Event": {
      "main": [[{ "node": "Create Event", "type": "main", "index": 0 }]]
    },
    "Create Event": {
      "main": [[{ "node": "Send Confirmation Email", "type": "main", "index": 0 }]]
    },
    "Send Confirmation Email": {
      "main": [[{ "node": "Final Booking Response", "type": "main", "index": 0 }]]
    },
    "IF Delete Event": {
      "main": [[{ "node": "Delete Event", "type": "main", "index": 0 }]]
    },
    "Delete Event": {
      "main": [[{ "node": "Cancel Response", "type": "main", "index": 0 }]]
    },
    "Final Booking Response": {
      "main": [[{ "node": "Format Output for LangChain", "type": "main", "index": 0 }]]
    },
    "Cancel Response": {
      "main": [[{ "node": "Format Output for LangChain", "type": "main", "index": 0 }]]
    },
    "Passthrough Response": {
      "main": [[{ "node": "Format Output for LangChain", "type": "main", "index": 0 }]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "473b8e2f44c2c249c630a674e0ffd242a718055278d7a389908825386c510f30"
  },
  "tags": []
}
