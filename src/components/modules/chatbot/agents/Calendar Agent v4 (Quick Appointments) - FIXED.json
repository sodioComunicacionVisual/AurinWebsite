{
  "name": "Calendar Agent v4 (Quick Appointments)",
  "nodes": [
    {
      "parameters": {},
      "id": "trigger-1",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [-1184, 288]
    },
    {
      "parameters": {
        "jsCode": "// === PARSEAR SOLICITUD v5 - ENHANCED ===\nconst inputJson = $input.item.json || {};\nconst query = (inputJson.query || '').toLowerCase();\nconst queryOriginal = inputJson.query || '';\nconst customerEmail = inputJson.customerEmail || '';\nconst pendingBookingIn = inputJson.pendingBooking || null;\nlet customerData = inputJson.customerData || null;\nlet action = 'check';\nlet targetDate = null;\nlet targetTime = null;\n\nconsole.log('=== PARSE REQUEST v5 ===');\nconsole.log('Query:', queryOriginal);\nconsole.log('PendingBooking:', JSON.stringify(pendingBookingIn));\nconsole.log('CustomerData:', JSON.stringify(customerData));\n\n// Detectar formato: BOOKING: name=..., email=..., reason=...\nconst bookingMatch = queryOriginal.match(/BOOKING:\\s*name\\s*=\\s*([^,]+),\\s*email\\s*=\\s*([^,]+)(?:,\\s*reason\\s*=\\s*(.+))?/i);\nif (bookingMatch) {\n  customerData = {\n    name: bookingMatch[1].trim(),\n    email: bookingMatch[2].trim(),\n    reason: bookingMatch[3] ? bookingMatch[3].trim() : 'Consulta general'\n  };\n  console.log('‚úÖ BOOKING detected:', JSON.stringify(customerData));\n  \n  // Si ya hay pendingBookingIn con horario, crear evento directamente\n  if (pendingBookingIn && pendingBookingIn.start && pendingBookingIn.end) {\n    action = 'create_event';\n    console.log('‚úÖ PendingBooking found, setting action to create_event');\n  } else {\n    // BOOKING sin horario: pedir horario\n    action = 'book';\n    console.log('‚ö†Ô∏è BOOKING without pendingBooking, will request time');\n  }\n} else {\n  // Acciones regulares\n  const isCancel = /(cancelar|eliminar|quitar|cancel)/i.test(query);\n  const isConfirm = /(confirmar|confirmo|si confirmo|confirm|yes)/i.test(query);\n  const isBooking = /(agendar|reservar|programar|cita|appointment|agendar|book)/i.test(query);\n\n  if (isBooking) action = 'book';\n  if (isCancel) action = 'cancel';\n  if (isConfirm) action = 'confirm';\n}\n\n// Extraer d√≠a y hora SOLO si action es 'book' y NO tenemos customerData\nif (action === 'book' && !customerData) {\n  const daysEs = ['lunes','martes','miercoles','mi√©rcoles','jueves','viernes','sabado','s√°bado','domingo'];\n  const daysEn = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];\n  \n  for (let i = 0; i < 7; i++) {\n    const d = new Date();\n    const diff = (i + 7 - d.getDay() + 1) % 7 || 7;\n    d.setDate(d.getDate() + diff);\n    if (query.includes(daysEs[i]) || query.includes(daysEn[i])) {\n      targetDate = d.toISOString().split('T')[0];\n      console.log('‚úÖ Date detected:', targetDate);\n      break;\n    }\n  }\n  \n  const timeMatch = query.match(/(\\d{1,2})(?::(\\d{2}))?\\s?(am|pm)?/i);\n  if (timeMatch) {\n    let [_, h, m, p] = timeMatch;\n    let hours = parseInt(h);\n    const minutes = m || '00';\n    if (p) {\n      if (p.toLowerCase() === 'pm' && hours !== 12) hours += 12;\n      if (p.toLowerCase() === 'am' && hours === 12) hours = 0;\n    }\n    targetTime = String(hours).padStart(2,'0') + ':' + minutes;\n    console.log('‚úÖ Time detected:', targetTime);\n  }\n\n  // Validar +24h anticipaci√≥n\n  if (targetDate && targetTime) {\n    const proposedDateTime = new Date(targetDate + 'T' + targetTime + ':00-06:00');\n    const minDateTime = new Date(Date.now() + 24*60*60*1000);\n\n    if (proposedDateTime < minDateTime) {\n      console.log('‚ùå Validation failed: less than 24h advance');\n      return [{\n        json: {\n          output: '‚è∞ Solo aceptamos citas con al menos **24 horas de anticipaci√≥n** para poder confirmarlas adecuadamente.\\n\\nEsto nos permite asegurar que recibir√°s tu email de confirmaci√≥n y podr√°s confirmar tu asistencia a tiempo.\\n\\n¬øQuieres ver horarios disponibles para m√°s adelante?',\n          action: 'error',\n          needsData: false,\n          pendingBooking: null,\n          customerData: null,\n          customerEmail: customerEmail,\n          validationFailed: true\n        }\n      }];\n    }\n  }\n}\n\nreturn [{\n  json: {\n    query,\n    action,\n    targetDate,\n    targetTime,\n    customerEmail,\n    customerData,\n    pendingBookingIn\n  }\n}];"
      },
      "id": "parse-request",
      "name": "Parse Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-960, 288]
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "mode": "list",
          "value": "primary"
        },
        "limit": 100,
        "options": {
          "orderBy": "startTime",
          "timeMin": "={{ new Date().toISOString() }}",
          "timeMax": "={{ new Date(Date.now() + 7*24*60*60*1000).toISOString() }}"
        }
      },
      "id": "get-events",
      "name": "Get Events",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [-736, 288],
      "alwaysOutputData": true,
      "continueOnFail": true,
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "GOOGLE_CALENDAR_CREDENTIAL_ID",
          "name": "Google Calendar Aurin"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === PROCESAR ACCI√ìN v5 - ENHANCED ERROR HANDLING ===\nconst parseData = $('Parse Request').item.json;\nconst { action, targetDate, targetTime, customerEmail, customerData, pendingBookingIn, validationFailed } = parseData;\n\nconsole.log('=== PROCESS ACTION v5 ===');\nconsole.log('Action:', action);\nconsole.log('TargetDate:', targetDate);\nconsole.log('TargetTime:', targetTime);\nconsole.log('CustomerData:', JSON.stringify(customerData));\nconsole.log('PendingBookingIn:', JSON.stringify(pendingBookingIn));\n\n// Si ya fall√≥ validaci√≥n, pasar directo\nif (validationFailed) {\n  return [{ json: parseData }];\n}\n\n// IMPROVED: Manejar errores de Google Calendar con m√°s detalle\nconst allItems = $input.all();\nlet events = [];\nlet apiError = null;\n\nif (allItems.length === 0) {\n  apiError = 'No response from Google Calendar API';\n  console.error('‚ùå Google Calendar API: No response');\n} else {\n  const firstItem = allItems[0].json;\n  \n  if (firstItem.error) {\n    apiError = firstItem.error.message || 'Google Calendar API error';\n    console.error('‚ùå Google Calendar API Error:', apiError);\n  } else if (firstItem.code && firstItem.code >= 400) {\n    apiError = `Google Calendar returned error ${firstItem.code}`;\n    console.error('‚ùå Google Calendar API Error Code:', firstItem.code);\n  } else if (!firstItem.id && !firstItem.summary && Object.keys(firstItem).length < 3) {\n    apiError = 'Invalid response from Google Calendar';\n    console.error('‚ùå Google Calendar API: Invalid response structure');\n  } else {\n    events = allItems.filter(i => i.json.id).map(i => i.json);\n    console.log(`‚úÖ Retrieved ${events.length} events from Google Calendar`);\n  }\n}\n\nif (apiError) {\n  return [{\n    json: {\n      output: '‚ö†Ô∏è Estamos teniendo problemas para conectar con el calendario en este momento. Por favor intenta de nuevo en unos minutos o contacta a hey@aurin.mx',\n      action: 'error',\n      needsData: false,\n      pendingBooking: null,\n      customerData: null,\n      customerEmail: customerEmail,\n      apiError: apiError\n    }\n  }];\n}\nconst allowedTimes = ['11:00','11:30','12:00','12:30','13:00','13:30','14:00','14:30','15:00','15:30','16:00','16:30','17:00','17:30'];\n\nlet response = '';\nlet needsData = false;\nlet pendingBooking = null;\nlet cancelEventId = null;\nlet shouldCreateEvent = false;\nlet shouldDeleteEvent = false;\n\nif (action === 'check') {\n  response = `üìÖ **Disponibilidad esta semana (CDMX, GMT-6)**\\n\\n`;\n  const days = ['Domingo','Lunes','Martes','Mi√©rcoles','Jueves','Viernes','S√°bado'];\n  const holidays = ['2025-11-17', '2025-12-25', '2026-01-01'];\n  \n  for (let i = 1; i < 8; i++) {\n    const d = new Date();\n    d.setDate(d.getDate() + i);\n    if (d.getDay() === 0 || d.getDay() === 6) continue;\n    const dateStr = d.toISOString().split('T')[0];\n    if (holidays.includes(dateStr)) continue;\n    \n    const busySlots = events\n      .filter(e => e.start?.dateTime?.startsWith(dateStr))\n      .map(e => ({\n        start: new Date(new Date(e.start.dateTime).getTime() - 15*60*1000),\n        end: new Date(new Date(e.end.dateTime).getTime() + 15*60*1000)\n      }));\n\n    const availableTimes = allowedTimes.filter(time => {\n      const proposedStart = new Date(`${dateStr}T${time}:00-06:00`);\n      const proposedEnd = new Date(proposedStart.getTime() + 30*60*1000);\n\n      return !busySlots.some(busy =>\n        proposedStart < busy.end && proposedEnd > busy.start\n      );\n    });\n\n    if (availableTimes.length > 0) {\n      response += `**${days[d.getDay()]} ${d.getDate()}**: ${availableTimes.join(', ')}\\n`;\n    }\n  }\n  response += `\\nüí° **Duraci√≥n:** 30 minutos\\n‚ö†Ô∏è **Importante:** Debes confirmar tu cita en 24h v√≠a email o ser√° cancelada autom√°ticamente.\\n\\n¬øQu√© d√≠a y hora prefieres? (Ej: \"Jueves a las 3 PM\")`;\n\n} else if (action === 'book') {\n  // Si tenemos customerData pero no horario, pedir horario\n  if (customerData && customerData.name && (!targetDate || !targetTime)) {\n    response = `Hola ${customerData.name}, necesito un horario para tu cita.\\n\\n‚è∞ Por favor elige d√≠a y hora. Ejemplo: \"Martes a las 11 AM\"\\n\\n**Horarios disponibles:** Lunes a Viernes, 11 AM-5:30 PM`;\n  } else if (!targetDate || !targetTime || !allowedTimes.includes(targetTime)) {\n    response = `‚è∞ Necesito un horario v√°lido. Ejemplo: \"Martes a las 11 AM\"\\n\\n**Horarios disponibles:** Lunes a Viernes, 11 AM-5:30 PM`;\n  } else {\n    const startISO = `${targetDate}T${targetTime}:00-06:00`;\n    const endISO = new Date(new Date(startISO).getTime() + 30*60*1000).toISOString();\n    \n    const busySlots = events\n      .filter(e => e.start?.dateTime?.startsWith(targetDate))\n      .map(e => ({\n        start: new Date(new Date(e.start.dateTime).getTime() - 15*60*1000),\n        end: new Date(new Date(e.end.dateTime).getTime() + 15*60*1000)\n      }));\n\n    const proposedStart = new Date(startISO);\n    const proposedEnd = new Date(endISO);\n\n    const conflict = busySlots.some(busy =>\n      proposedStart < busy.end && proposedEnd > busy.start\n    );\n\n    if (conflict) {\n      response = `‚ùå Lo siento, ese horario ya est√° ocupado o muy cerca de otra cita.\\n\\n¬øQuieres ver otros horarios disponibles?`;\n    } else if (customerData && customerData.name && customerData.email) {\n      // Tenemos datos + horario v√°lido ‚Üí crear evento\n      response = `Creando tu cita...`;\n      shouldCreateEvent = true;\n      pendingBooking = { start: startISO, end: endISO };\n    } else {\n      // Horario v√°lido pero faltan datos ‚Üí pedir datos\n      response = `‚úÖ ¬°Perfecto! Confirmemos tu cita r√°pida:\\n\\nüìÖ **${new Date(startISO).toLocaleString('es-MX',{weekday:'long',month:'long',day:'numeric',hour:'numeric',minute:'numeric'})}**\\n‚è±Ô∏è Duraci√≥n: 30 minutos\\nüé• Incluye enlace de videollamada\\n\\nPara confirmar, necesito:\\n1. **Nombre completo**\\n2. **Email**\\n3. **¬øDe qu√© trata tu consulta?** (breve)\\n\\n‚ö†Ô∏è **Importante:** Recibir√°s un email de confirmaci√≥n. Debes confirmar en las pr√≥ximas 24 horas o tu cita ser√° cancelada autom√°ticamente.\\n\\n_Responde con esta info y agendar√© tu cita._`;\n      needsData = true;\n      pendingBooking = { start: startISO, end: endISO };\n    }\n  }\n\n} else if (action === 'create_event') {\n  response = `Creando tu cita...`;\n  shouldCreateEvent = true;\n\n} else if (action === 'cancel') {\n  if (!customerEmail) {\n    response = `Para cancelar, necesito el email con el que agendaste.`;\n  } else {\n    const pending = events.find(e => \n      e.attendees?.some(a => a.email === customerEmail) && \n      (e.summary.includes('[PENDIENTE') || e.summary.includes('[CONFIRMADA'))\n    );\n    if (pending) {\n      cancelEventId = pending.id;\n      shouldDeleteEvent = true;\n      response = `Cancelando tu cita...`;\n    } else {\n      response = `No encontr√© ninguna cita con tu email **${customerEmail}**.`;\n    }\n  }\n\n} else if (action === 'confirm') {\n  response = `Para confirmar tu cita, usa el bot√≥n en el email que te enviamos. Si no lo recibiste, cont√°ctanos a hey@aurin.mx`;\n} else {\n  // Fallback para acciones no reconocidas\n  response = `No entend√≠ tu solicitud. ¬øQuieres ver la disponibilidad o agendar una cita?`;\n}\n\nreturn [{\n  json: {\n    output: response,\n    needsData,\n    pendingBooking,\n    cancelEventId,\n    action,\n    customerData: parseData.customerData,\n    pendingBookingIn: pendingBooking || parseData.pendingBookingIn,\n    shouldCreateEvent,\n    shouldDeleteEvent\n  }\n}];"
      },
      "id": "process-action",
      "name": "Process Action",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-512, 288]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [{ "value1": "={{ $json.shouldCreateEvent }}", "value2": true }]
        }
      },
      "id": "if-create",
      "name": "IF Create Event",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [-288, 32]
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "mode": "list",
          "value": "primary"
        },
        "start": "={{ $json.pendingBookingIn.start }}",
        "end": "={{ $json.pendingBookingIn.end }}",
        "title": "={{ '[PENDIENTE CONFIRMACI√ìN] Cita R√°pida - ' + $json.customerData.name }}",
        "description": "={{ 'Consulta: ' + ($json.customerData.reason || 'No especificado') + '\\n\\nEsta cita requiere confirmaci√≥n del usuario en las pr√≥ximas 24 horas.\\n\\nContacto: ' + $json.customerData.email }}",
        "useDefaultReminders": false,
        "additionalFields": {
          "attendees": "={{ $json.customerData.email }}",
          "conferenceDataVersion": 1
        }
      },
      "id": "create-event",
      "name": "Create Event",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [-64, -80],
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "GOOGLE_CALENDAR_CREDENTIAL_ID",
          "name": "Google Calendar Aurin"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://aurin.mx/api/send-appointment-confirmation",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"name\": $json.customerData.name,\n  \"email\": $json.customerData.email,\n  \"appointmentDate\": $('Create Event').item.json.start.dateTime,\n  \"meetLink\": $('Create Event').item.json.hangoutLink,\n  \"eventId\": $('Create Event').item.json.id,\n  \"calendarLink\": $('Create Event').item.json.htmlLink\n} }}",
        "options": {}
      },
      "id": "send-confirmation",
      "name": "Send Confirmation Email",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [160, -80]
    },
    {
      "parameters": {
        "jsCode": "const event = $('Create Event').item.json;\nconst customerData = $('Process Action').item.json.customerData;\n\nconsole.log('=== FINAL BOOKING RESPONSE ===');\nconsole.log('Event:', JSON.stringify(event));\nconsole.log('CustomerData:', JSON.stringify(customerData));\n\n// IMPROVED: Validar evento creado con m√°s detalle\nif (!event || !event.id) {\n  console.error('‚ùå Event creation failed - no event or no event ID');\n  return [{\n    json: {\n      output: '‚ùå **Error al crear tu cita en el calendario**\\n\\nNo pudimos completar la reserva. Por favor intenta nuevamente en unos minutos.\\n\\nSi el problema persiste, contacta directamente a hey@aurin.mx',\n      error: event?.error?.message || 'No event ID returned',\n      pendingBooking: null,\n      customerData: null,\n      customerEmail: customerData?.email || ''\n    }\n  }];\n}\n\nif (!event.start?.dateTime || !event.htmlLink) {\n  console.error('‚ùå Event missing required fields');\n  return [{\n    json: {\n      output: '‚ö†Ô∏è **Cita creada pero con informaci√≥n incompleta**\\n\\nTu cita fue agendada pero faltan algunos detalles. Por favor contacta a hey@aurin.mx para verificar.',\n      eventId: event.id,\n      pendingBooking: null,\n      customerData: null,\n      customerEmail: customerData?.email || ''\n    }\n  }];\n}\n\nif (!event.hangoutLink) {\n  console.warn('‚ö†Ô∏è Event created but no Meet link generated');\n}\n\nconst displayDate = new Date(event.start.dateTime).toLocaleString('es-MX', {\n  weekday: 'long',\n  month: 'long',\n  day: 'numeric',\n  hour: 'numeric',\n  minute: 'numeric',\n  timeZone: 'America/Mexico_City'\n});\n\nreturn [{\n  json: {\n    output: `‚úÖ **¬°Cita reservada exitosamente, ${customerData.name}!**\\n\\nüìÖ **${displayDate} (hora Ciudad de M√©xico, GMT-6)**\\n‚è±Ô∏è Duraci√≥n: 30 minutos\\nüé• Enlace Meet: ${event.hangoutLink || 'Se enviar√° por email'}\\n\\nüìß **IMPORTANTE:** Te enviamos un email de confirmaci√≥n a **${customerData.email}**.\\n\\n‚ö†Ô∏è **Debes confirmar tu cita en las pr√≥ximas 24 horas haciendo clic en el bot√≥n del email, o ser√° cancelada autom√°ticamente.**\\n\\nSi no recibes el email, revisa spam o cont√°ctanos en hey@aurin.mx`,\n    eventId: event.id,\n    calendarLink: event.htmlLink,\n    pendingBooking: null,\n    customerData: null,\n    customerEmail: ''\n  }\n}];"
      },
      "id": "final-response",
      "name": "Final Booking Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [384, -80]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [{ "value1": "={{ $json.shouldDeleteEvent }}", "value2": true }]
        }
      },
      "id": "if-delete",
      "name": "IF Delete Event",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [-288, 400]
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "mode": "list",
          "value": "primary"
        },
        "eventId": "={{ $json.cancelEventId }}",
        "options": { "sendUpdates": "all" }
      },
      "id": "delete-event",
      "name": "Delete Event",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [-64, 288],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "GOOGLE_CALENDAR_CREDENTIAL_ID",
          "name": "Google Calendar Aurin"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { output: `‚úÖ Cita cancelada exitosamente.\\n\\n¬øDeseas agendar una nueva cita r√°pida?` } }];"
      },
      "id": "cancel-response",
      "name": "Cancel Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [160, 288]
    },
    {
      "parameters": {
        "jsCode": "return [$json];"
      },
      "id": "passthrough",
      "name": "Passthrough Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-64, 160]
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Simplificado - solo retornar output\nreturn [{ json: { output: $json.output || 'Error: No se pudo procesar la solicitud' } }];"
      },
      "id": "format-output",
      "name": "Format Output for LangChain",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [160, 160]
    }
  ],
  "pinData": {},
  "connections": {
    "Execute Workflow Trigger": {
      "main": [[{ "node": "Parse Request", "type": "main", "index": 0 }]]
    },
    "Parse Request": {
      "main": [[{ "node": "Get Events", "type": "main", "index": 0 }]]
    },
    "Get Events": {
      "main": [[{ "node": "Process Action", "type": "main", "index": 0 }]]
    },
    "Process Action": {
      "main": [[
        { "node": "IF Create Event", "type": "main", "index": 0 },
        { "node": "IF Delete Event", "type": "main", "index": 0 },
        { "node": "Passthrough Response", "type": "main", "index": 0 }
      ]]
    },
    "IF Create Event": {
      "main": [[{ "node": "Create Event", "type": "main", "index": 0 }]]
    },
    "Create Event": {
      "main": [[{ "node": "Send Confirmation Email", "type": "main", "index": 0 }]]
    },
    "Send Confirmation Email": {
      "main": [[{ "node": "Final Booking Response", "type": "main", "index": 0 }]]
    },
    "IF Delete Event": {
      "main": [[{ "node": "Delete Event", "type": "main", "index": 0 }]]
    },
    "Delete Event": {
      "main": [[{ "node": "Cancel Response", "type": "main", "index": 0 }]]
    },
    "Final Booking Response": {
      "main": [[{ "node": "Format Output for LangChain", "type": "main", "index": 0 }]]
    },
    "Cancel Response": {
      "main": [[{ "node": "Format Output for LangChain", "type": "main", "index": 0 }]]
    },
    "Passthrough Response": {
      "main": [[{ "node": "Format Output for LangChain", "type": "main", "index": 0 }]]
    }
  },
  "active": false,
  "settings": { "executionOrder": "v1" },
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "473b8e2f44c2c249c630a674e0ffd242a718055278d7a389908825386c510f30"
  },
  "tags": []
}
